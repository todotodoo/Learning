1. Objective-C implementation:
     1). GCC
     2). NeXT
     3). Apple
     4). Portable Object Compiler

2. 不支持内联函数，但是Block可以达到类似的效果；不支持namespace、multiple inheritance、operator overloading.

3. Category
     1). 在没有source code和recompile的情况下为class添加方法；
     2). Category覆盖原有的方法；
     3). 如果有两个Category包含相同的method，这种情况下会使用哪个是未定义的；
     4). 在Category加入方法，不仅影响当前class，同样会影响其子class。所以像NSObject这样的Root class加Category是很危险的；
     5). 在Category加入方法可能会打乱原有的设计；
     6). object/category的名字必须是全局唯一的。因为Objective-C的namespace is shared between the program code and all the libraries, frameworks, and plug-ins.

4. Cocoa Touch API for iOS. 主要包含：gesture recognition，animation.
     Foundation Kit Framework
     UIKit Framework
     ...

5. Class Extensions: 与Category不同，在（）省略。
     1). Adding additional instance variables and properties;
     2). 实现职能在main implementation section中，不能在separate implementation;
     3). Methods are private. 但if someone owns the name of a private method, she can still call it.
注：Category重写方法，后，原来的方法就无法简单调用到了。但是，派生类重写，可以通过super关键字调用。如果在Category重写方法后，也可以通过Objective-C的Runtime来调用原有方法，method_exchangeImplemetation.

6. Objective-C函数参数传递：
     1). 传variable值传递；
     2). object时，引用。

7. Copy

     copyWithZone 返回一个immutable copy;
     mutableCopyWithZone 返回一个mutable one. 如：

     @interface Fraction : NSObject <NSCopying>

     @implementation
     -(id)copyWithZone:(NSZone *)zone {
         Fraction *newFrac = [[Fraction allWithZone:zone] init];
         //...
          return newFrac;
     }
     @end

8. 关于copyWithZone的使用注意事项：
     1). 该方法会被子类继承；
     2). 如果当前类的父类也实现了<NSCopying> protocol，则应调用父类的copy，然后再是该类的copy的代码。

9. NSString, NSDictionary, NSArray, NSDate, NSNumber等writeToFile:方法，会再temporary backup file写入成功后再移到目的地。这样做是为了防止在写的时候出现corrupt，保证原始文件不会被harmed。

10. delegate关心返回；而notification则关注通知。

11. SEL是selector的一个类型，表示一个方法的名字。@selector
     id是struct objc_object的一个指针，声明不需要加*。id是一个指向任何一个继承了Object类的对象。
     nil指向一个Objective-C对象，这个对象的指针指向空。
     Nil则指向空的类（是class，不是对象）
     IMP定义为id(*IMP)(id, SEL, …) 一个指向函数的指针，这个被指向的函数包括id(“self”指针), 调用SEL(方法名)，再加上其他参数，说明IMP就是实现方法。

12. KVC(Key-Value Coding) NSKeyValueCoding， 一个非正式的protocol，提供一种机制来间接访问对象的属性。

     void changeValue(Person *p, NSString *newName) {
          NSString *originName = [p valueForKey:@"name"];
          [p setValue:newName forKey:@“name"];
          NSString *spouseName = [p valueForKeyPath:@“spouse.name"];
          //==[[p valueForKey:@“spouse”] valueForKey:@“name"];
     }

     注册指定路径的监听器：addObserver:forKeyPath:options:context:
     删除指定路径的监听器：removeObserver:forKeyPath、removeObserver:forKeyPath:context:
     回调监听方法：observerValueForKeyPath:foObject:change:context:

     KVO使用步骤：
     1). 通过addObserver:forKeyPath:options:context:，为监听对象（通常为数据模型）注册监听器；
     2). 重写监听器的observerValueForKeyPath:ofObject:change:context:方法。

13. 几点需要注意的：
     1). 不要在initialiter和dealloc中使用accessor method(如self.property = ...);
     2). foundamental collection class移除时，会对其拥有的对象发送release（而不是autorelease）消息。如：
          aObject = [array objectAtIndex:n];
          [array removeObjectAtIndex:n];
          //aObject此时已经无效
          
          改为：
          aObject = [[array objectAtIndex:n] retain];
          [array removeObjectAtIndex:n];
          //use aObject
          [aObject release];
     3). 注意不要对这些内存管理操作：file descriptors, network connections, buffers, caches in a dealloc method.
     
14. Collections own the objects they contain.
    NSMutableArray *array = [[NSMutableArray alloc] init];
    NSInteger i;
    
    for (i = 0; i < 10; ++i) {
          NSNumber *convenienceNumber = [NSNumber numberWithInteger: i];
          [array addObject:convenienceNumber];
          //==
          NSNumber *allocNumber = [[NSNumber alloc] initWithInteger:i];
          [array addObject: allocNumber];//会retain
          [allocNumber release];
          
     }
     
15. Objective-C Runtime编程
     1). Dynamically loading new classes at runtime;
     2). Forwarding message to other objects;
     3). Find information about objects.
     
     isKindOfClass是否是class或者其派生class的对象；
     isMemberOfClass是否是该class的对象，比isKindOfClass严格；
     respondsToSelector是否实现了某个method；
     conformsToProtocol是否遵守讴歌特定的protocol；
     methodForSelector获得一个指向方法实现的指针。由Cocoa runtime system提供，不是Objective-C特性，比message快，
     一般在调用次数多的时候才那么用。
     
     void(*setter)(id, SEL, BOOL);
     int i;
     setter = (void(*)(id, SEL, BOOL))[target methodForSelector:@selector(setFailed:)];
     for (i = 0; i < 100; ++i) {
          setter(target[i], @selector(setFailed:), YES);
     }
     
     提供C语言使用函数接口，也就是Plain C。使用Objective-C特性。
     /usr/include/objc

16. 动态方法实现（Dynamic Method Resolution）
     resolveInstanceMethod:
     resolveClassMethod:
     
     void dynamicMethodIMP(id self, SEL __cmd) {
          //...
     }
     
     +(BOOL)resolveInstanceMethod:(SEL)aSEL {
          if (aSEL == @selector(resolveThisMethodDynamically)) {
               class_addMethod([self class], aSEL, (IMP)dynamicMethodIMP, "v@:");
               return YES;
          }
          
          return [super resolveInstanceMethod:aSEL];
     }

17. 动态加载（Dynamic Loading）
     1). objc/objc_load.h     objc_loadModules
     2). Cocoa's NSBundle

18. NSInvocation
     实现forwardInvocation: 给message一个默认回复，以免运行时错误。
     
     工作方法：
     When an object can't respond to a message because it doesn't have a method matching the selector in
     the message, the runtime system informs(通知) the object by sending it a forwardInvocation: message.

     To forward a message, all a forwardInvocation: method needs to do is:
     1). Determine where the message should go, and 
     2). send it there with its original arguments.
     
     -(void)forwardInvocation:(NSInvocation *)anInvocation {
          if ([someOtherObject respondsToSelector:[anInvocation selector]]) {
               [anInvocation invokeWithTarget:someOtherObject];
          } else {
               [super forwardInvocation:anInvocation];
          }
     }
     
     对于unrecognized messages，一个forwardInvocation:方法起到一个分发中心的作用。注意：只有在处理不存在
     的method时，runtime system才会向object发送forwardInvocation:消息。
     
     
     Forwarding：
     1). Multiple Inheritance；
     2). Surrogate objects。
     
     注意：respondsToSelector:和isKindOfClass:只会查找继承关系链，不会查找forwarding chain。如果想你的objects to act
     as if they truly inherited the behavior of the objects they forward messages to, ni需要重新实现respondsToSelector:和
     isKindOfClass:，还有instanceRespondToSelector:，conformsToProtocol:，methodSignatureForSelector:。








